import { Component, ChangeDetectorRef, Injectable, Input, ElementRef, ChangeDetectionStrategy } from '@angular/core';
import { ScrollSpyService } from '../index';
import { ScrollSpyIndexService } from './index.service';
var ScrollSpyIndexRenderComponent = (function () {
    function ScrollSpyIndexRenderComponent(ref, elRef, scrollSpy, scrollSpyIndex) {
        this.ref = ref;
        this.elRef = elRef;
        this.scrollSpy = scrollSpy;
        this.scrollSpyIndex = scrollSpyIndex;
        this.items = [];
        this.itemsHash = {};
        this.itemsToHighlight = [];
        this.defaultOptions = {
            spyId: 'window',
            topMargin: 0
        };
        this.el = elRef.nativeElement;
    }
    ScrollSpyIndexRenderComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (!this.scrollSpyIndexRenderOptions) {
            this.scrollSpyIndexRenderOptions = {};
        }
        if (!this.scrollSpyIndexRenderOptions.id) {
            return console.warn('ScrollSpyIndex: Missing id.');
        }
        this.scrollSpyIndexRenderOptions = Object.assign(this.defaultOptions, this.scrollSpyIndexRenderOptions);
        this.changeStream$ = this.scrollSpyIndex.changes$.subscribe(function (e) {
            if (e.index === _this.scrollSpyIndexRenderOptions.id) {
                if (e.change === 'delete') {
                    _this.update();
                }
                else if (e.change === 'set') {
                    _this.update();
                }
            }
        });
    };
    ScrollSpyIndexRenderComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!!this.scrollSpy.getObservable(this.scrollSpyIndexRenderOptions.spyId)) {
            this.scrollStream$ = this.scrollSpy.getObservable(this.scrollSpyIndexRenderOptions.spyId).subscribe(function (e) {
                if (typeof e.target.scrollingElement !== 'undefined') {
                    _this.currentScrollPosition = e.target.scrollingElement.scrollTop;
                }
                else if (typeof e.target.scrollY !== 'undefined') {
                    _this.currentScrollPosition = e.target.scrollY;
                }
                else if (typeof e.target.pageYOffset !== 'undefined') {
                    _this.currentScrollPosition = e.target.pageYOffset;
                }
                _this.calculateHighlight();
            });
        }
        else {
            return console.warn('ScrollSpyIndexComponent: No ScrollSpy observable for id "' + this.scrollSpyIndexRenderOptions.spyId + '"');
        }
    };
    ScrollSpyIndexRenderComponent.prototype.update = function () {
        var _this = this;
        var data = this.scrollSpyIndex.getIndex(this.scrollSpyIndexRenderOptions.id) || [];
        var stack = [];
        var parentStack = [];
        var lastItem;
        this.items = [];
        this.itemsHash = {};
        for (var i = 0; i < data.length; ++i) {
            // parse basic info from the dom item
            var item = {
                link: data[i].id,
                text: data[i].textContent || data[i].innerText,
                parents: [],
                children: []
            };
            // build type identifier
            var level = data[i].tagName;
            for (var n = 0; n < data[i].classList.length; n++) {
                level += ',' + data[i].classList[n];
            }
            // here be dragons
            var stacksize = stack.length;
            if (stacksize === 0) {
                // we are at the top level and will stay there
                stack.push(level);
            }
            else if (level !== stack[stacksize - 1]) {
                // traverse the ancestry, looking for a match
                for (var j = stacksize - 1; j >= 0; j--) {
                    if (level === stack[j]) {
                        break; // found an ancestor
                    }
                }
                if (j < 0) {
                    // this is a new submenu item, lets push the stack
                    stack.push(level);
                    parentStack.push(lastItem);
                }
                else {
                    // we are either a sibling or higher up the tree,
                    // lets pop the stack if needed
                    while (stack.length > j + 1) {
                        stack.pop();
                        parentStack.pop();
                    }
                }
            }
            // for next iteration
            lastItem = item.link;
            // if we have a parent, lets record it
            if (parentStack.length > 0) {
                item.parents = parentStack.slice();
                var temp = this.items;
                for (var t = 0; t < parentStack.length; ++t) {
                    if (t < parentStack.length - 1) {
                        temp = temp.filter(function (e) { return e.link === parentStack[t]; })[0].children;
                    }
                    else {
                        temp.filter(function (e) { return e.link === parentStack[t]; })[0].children.push(item);
                    }
                }
            }
            else {
                this.items.push(item);
            }
            this.itemsHash[item.link] = item;
        }
        setTimeout(function () {
            _this.calculateHighlight();
        });
    };
    ScrollSpyIndexRenderComponent.prototype.calculateHighlight = function () {
        var items = this.scrollSpyIndex.getIndex(this.scrollSpyIndexRenderOptions.id);
        this.itemsToHighlight = [];
        if (!items || !items.length) {
            return;
        }
        var highlightItem;
        for (var i = items.length - 1; i >= 0; i--) {
            if (this.currentScrollPosition - (items[i].offsetTop + this.scrollSpyIndexRenderOptions.topMargin) >= 0) {
                highlightItem = items[i].id;
                break;
            }
        }
        if (!highlightItem) {
            highlightItem = items[0].id;
        }
        this.itemsToHighlight = [highlightItem].concat(this.itemsHash[highlightItem].parents);
        this.ref.markForCheck();
    };
    ScrollSpyIndexRenderComponent.prototype.highlight = function (id) {
        return this.itemsToHighlight.indexOf(id) !== -1;
    };
    ScrollSpyIndexRenderComponent.prototype.goTo = function (anchor) {
        setTimeout(function () {
            document.querySelector('#' + anchor).scrollIntoView();
        });
    };
    ScrollSpyIndexRenderComponent.prototype.ngOnDestroy = function () {
        this.changeStream$.unsubscribe();
        this.scrollStream$.unsubscribe();
    };
    return ScrollSpyIndexRenderComponent;
}());
export { ScrollSpyIndexRenderComponent };
ScrollSpyIndexRenderComponent.decorators = [
    { type: Injectable },
    { type: Component, args: [{
                selector: 'scrollSpy-index-render',
                template: "\n  <div #container>\n    <ul class=\"nav flex-column menu\">\n      <li *ngFor=\"let item of items\" [class.active]=\"highlight(item.link)\">\n        <a [routerLink]=\"\" fragment=\"{{item.link}}\" (click)=\"goTo(item.link)\">{{item.text}}</a>\n        <ul *ngIf=\"item.children.length\" class=\"nav menu\">\n          <li *ngFor=\"let itemChild of item.children\" [class.active]=\"highlight(itemChild.link)\">\n            <a [routerLink]=\"\" fragment=\"{{itemChild.link}}\" (click)=\"goTo(itemChild.link)\">{{itemChild.text}}</a>\n            <ul *ngIf=\"itemChild.children.length\" class=\"nav menu\">\n              <li *ngFor=\"let itemChild1 of itemChild.children\" [class.active]=\"highlight(itemChild1.link)\">\n                <a [routerLink]=\"\" fragment=\"{{itemChild1.link}}\" (click)=\"goTo(itemChild1.link)\">{{itemChild1.text}}</a>\n                 <ul *ngIf=\"itemChild1.children.length\" class=\"nav menu\">\n                  <li *ngFor=\"let itemChild2 of itemChild1.children\" [class.active]=\"highlight(itemChild2.link)\">\n                    <a [routerLink]=\"\" fragment=\"{{itemChild2.link}}\" (click)=\"goTo(itemChild2.link)\">{{itemChild2.text}}</a>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </div>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
ScrollSpyIndexRenderComponent.ctorParameters = function () { return [
    { type: ChangeDetectorRef, },
    { type: ElementRef, },
    { type: ScrollSpyService, },
    { type: ScrollSpyIndexService, },
]; };
ScrollSpyIndexRenderComponent.propDecorators = {
    'scrollSpyIndexRenderOptions': [{ type: Input },],
};
